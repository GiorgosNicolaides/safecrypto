// src/pages/cwe/CWE1204.tsx
import React from 'react';
import BackgroundWrapper from '../../components/BackgroundWrapper';
import DoDontLayout from '../../components/DoDontLayout';
import Slideshow from '../../components/Slideshow';

const CWE1204: React.FC = () => {
  const bestPractices = [
    'Generate IVs using a cryptographically secure RNG (e.g., `os.urandom(16)`).',
    'Ensure each IV is unique and never reused with the same key.',
    'Prefer AEAD modes (AES-GCM, ChaCha20-Poly1305) where IV/nonce handling is built-in.',
    'When using CBC, prepend the random IV in cleartext and validate it on decryption.'
  ];

  const goodCodeSamples = [
    `# ✅ Good: AES-CBC with secure random IV
import os
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

key = os.urandom(32)           # 256-bit key
iv = os.urandom(16)            # cryptographically secure IV
cipher = AES.new(key, AES.MODE_CBC, iv)
ciphertext = iv + cipher.encrypt(pad(b"Secret data", AES.block_size))`,

    `# ✅ Good: AEAD mode avoids manual IV management
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

key = AESGCM.generate_key(bit_length=256)
aesgcm = AESGCM(key)
nonce = os.urandom(12)         # AEAD nonce size
ciphertext = aesgcm.encrypt(nonce, b"Sensitive payload", None)`
  ];

  const badPractices = [
    'Do not use fixed or all-zero IVs (e.g., `b"\\x00"*16`).',
    'Never derive IVs from predictable sources (timestamps, counters).',
    'Avoid using non-crypto RNGs (e.g., `random.getrandbits`) for IVs.',
    'Do not reuse an IV with the same key—this leaks plaintext patterns.'
  ];

  const badCodeSamples = [
    `# ❌ Bad: static zero IV
from Crypto.Cipher import AES

key = b"0123456789abcdef0123456789abcdef"
iv = b"\\x00" * 16           # fixed, predictable
cipher = AES.new(key, AES.MODE_CBC, iv)
ciphertext = cipher.encrypt(pad(b"Hello", AES.block_size))`,

    `# ❌ Bad: timestamp-based IV
import time, os
from Crypto.Cipher import AES

key = os.urandom(32)
iv = int(time.time()).to_bytes(16, 'big')  # predictable
cipher = AES.new(key, AES.MODE_CBC, iv)
ct = iv + cipher.encrypt(pad(b"Data", AES.block_size))`
  ];

  return (
    <BackgroundWrapper>
      <DoDontLayout
        left={
          <>
            <div style={{ color: '#ffe81f', textAlign: 'left' }}>
              <h3>✔️ Best Practices</h3>
              <ul>
                {bestPractices.map((pt, i) => <li key={i}>{pt}</li>)}
              </ul>
            </div>
            <Slideshow
              slides={goodCodeSamples.map((code, i) => (
                <pre
                  key={i}
                  style={{
                    background: '#222',
                    color: '#fff',
                    padding: '1rem',
                    borderRadius: '4px',
                    overflowX: 'auto',
                    fontFamily: 'monospace',
                    width: '100%'
                  }}
                >
                  <code>{code}</code>
                </pre>
              ))}
            />
          </>
        }
        right={
          <>
            <div style={{ color: '#ffe81f', textAlign: 'left' }}>
              <h3>❌ Bad Practices</h3>
              <ul>
                {badPractices.map((pt, i) => <li key={i}>{pt}</li>)}
              </ul>
            </div>
            <Slideshow
              slides={badCodeSamples.map((code, i) => (
                <pre
                  key={i}
                  style={{
                    background: '#222',
                    color: '#fff',
                    padding: '1rem',
                    borderRadius: '4px',
                    overflowX: 'auto',
                    fontFamily: 'monospace',
                    width: '100%'
                  }}
                >
                  <code>{code}</code>
                </pre>
              ))}
            />
          </>
        }
      />

      <section
        style={{
          maxWidth: 800,
          margin: '2rem auto',
          color: '#fff',
          fontFamily: 'sans-serif',
          lineHeight: 1.6
        }}
      >
        <h2 style={{ color: '#ffe81f', textAlign: 'center' }}>
          Understanding CWE-1204
        </h2>
        <p>
          CWE-1204, “Generation of Weak Initialization Vector (IV),” occurs when applications
          create IVs that are predictable, reused, or generated by non-cryptographic means.
          In CBC mode, a weak IV leaks patterns in ciphertext and can facilitate chosen-plaintext
          or replay attacks.
        </p>
        <p>
          Proper IV generation requires a cryptographically secure random source and a fresh
          IV for each encryption. AEAD algorithms like AES-GCM handle this automatically,
          avoiding manual mistakes.
        </p>
        <h3 style={{ color: '#ffe81f' }}>Real-World CVE Examples</h3>
        <ul style={{ listStyle: 'disc inside' }}>
          <li>
            <strong>CVE-2017-3225</strong>: A device bootloader used a zero IV for AES-CBC, enabling
            attackers to decrypt firmware images and extract secrets :contentReference[oaicite:0].
          </li>
          <li>
            <strong>CVE-2016-6485</strong>: A PHP crypto framework generated IVs with <code>rand()</code>
            (not CSPRNG), resulting in predictable IVs and plaintext recovery :contentReference[oaicite:1].
          </li>
        </ul>
        <p>
          To remediate, always use CSPRNGs (e.g., <code>os.urandom</code>) for IVs, avoid reuse,
          and prefer high-level AEAD primitives that manage nonces/IVs correctly.
        </p>
      </section>
    </BackgroundWrapper>
  );
};

export default CWE1204;
